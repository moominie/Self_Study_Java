# Chapter 03. 연산자



## 03-1. 연산자와 연산식



##### <핵심 키워드>

`연산자`, `피연산자`, `연산 방향`, `연산 우선순위`     



###### 연산자

연산에 사용되는 표시나 기호   



###### 피연산자

연산자와 함께 연산되는 데이터  



###### 연산식

연산자와 피연산자를 이용하여 연산의 과정을 기술한 것  



### 03-1-1. 연산자의 종류

| 연산자 종류 | 연산자                           | 피연산자 수 | 산출값  | 기능                                  |
| ----------- | -------------------------------- | ----------- | ------- | ------------------------------------- |
| 산술        | +, -, *, /, %                    | 이항        | 숫자    | 사칙연산 및 나머지 계산               |
| 부호        | +, -                             | 단항        | 숫자    | 음수와 양수의 부호                    |
| 문자열      | +                                | 이항        | 문자열  | 두 문자열을 연결                      |
| 대입        | =, +=, -=, *=, /=, %=            | 이항        | 다양    | 우변의 값을 좌변의 변수에 대입        |
| 증감        | ++, --                           | 단항        | 숫자    | 1만큼 증가/감소                       |
| 비교        | ==, !=, >, <, >=, <=, instanceof | 이항        | boolean | 값의 비교                             |
| 논리        | !, &, \|, &&, \|\|               | 단항, 이항  | boolean | 논리 부정, 논리곱, 논리합             |
| 조건        | (조건식) ? A : B                 | 삼항        | 다양    | 조건식에 따라 A 또는 B 중 하나를 선택 |

연산식은 반드시 하나의 값을 산출하므로, 하나의 값이 올 수 있는 곳에 값 대신 연산식을 사용할 수 있음    



### 03-1-2. 연산의 방향과 우선순위

1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가짐
2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가짐
3. 대부분의 연산자는 왼쪽에서 오른쪽 방향으로 연산을 수행함  

​		단, 단항(++, --, ~, !), 부호(+, -), 대입(=, +=, -=, *=, /=, %=) 연산자는 오른쪽에서 왼쪽 방향으로 연산을 수행함   

(예시) `a = b = c = 5` 실행 순서 : c = 5, b = c, a = b   

4. 괄호( ) 부분의 연산은 최우선순위를 갖기 때문에 다른 연산자보다 우선 연산됨  

​		따라서 복잡한 연산식에서는 괄호( )를 사용해서 먼저 처리해야 할 연산식을 묶어주는 것이 좋음



## 03-2. 연산자의 종류



##### <핵심 키워드>

`증감 연산자`, `비교 연산자`, `논리 연산자`, `대입 연산자`, `삼항 연산자`    



### 03-2-1. 단항 연산자

###### 단항 연산자

피연산자가 하나뿐인 연산자  



##### 부호 연산자(+, -)

정수 및 실수 리터럴 앞에 붙여 양수 및 음수를 표시하거나, 변수 앞에 붙여 변수의 부호를 유지하거나 변경함  

| 연산식     | 설명                 |
| ---------- | -------------------- |
| + 피연산자 | 피연산자의 부호 유지 |
| - 피연산자 | 피연산자의 부호 변경 |



*int 이하 정수 타입에 부호 연산자를 붙이면 그 결과가 int 타입이 됨*

```java
byte b = 100;
int result = -b;
```



##### 증감 연산자(++, --)

변수의 값을 1 증가(++)시키거나 1 감소(--)시키는 연산자  

| 연산식      | 설명                                                 |
| ----------- | ---------------------------------------------------- |
| ++ 피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴 |
| -- 피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴 |
| 피연산자 ++ | 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴   |
| 피연산자 -- | 다른 연산을 수행한 후에 피연산자의 값을 1 감소시킴   |



```java
int x = 1;
int y = 1;
int result1 = ++x + 10; // result1 = 12, x = 2
int result2 = y++ + 10; // result2 = 11, y = 2
```



##### 논리 부정 연산자(!) 

논리부정연산자는 true를 false로, false를 true로 변경하기 때문에 boolean 타입에만 사용할 수 있음  

| 연산식     | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| ! 피연산자 | 피연산자가 true이면 false 값을 산출, 피연산자가 false이면 true 값을 산출 |



### 03-2-2. 이항 연산자

###### 이항 연산자

피연산자가 2개인 연산자  



##### 산술 연산자(+, -, *, /, %)   

사칙연산자인 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지를 구하는 % 연산자  

| 연산식              | 설명                                                        |
| ------------------- | ----------------------------------------------------------- |
| 피연산자 + 피연산자 | 덧셈 연산                                                   |
| 피연산자 - 피연산자 | 뺄셈 연산                                                   |
| 피연산자 * 피연산자 | 곱셈 연산                                                   |
| 피연산자 / 피연산자 | 왼쪽 피연산자를 오른쪽 피연산자로 나눗셈 연산               |
| 피연산자 % 피연산자 | 왼쪽 피연산자를 오른쪽 피연산자로 나눈 나머지를 구하는 연산 |



*산술 연산자는 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산을 수행함*

1. 피연산자들이 byte, short, char 타입일 경우 모두 int 타입으로 변환된 후에 연산을 수행함
2. 피연산자들이 모두 정수 타입이고 long 타입이 포함되어 있을 경우, 모두 long 타입으로 변환된 후 연산을 수행함
3. 피연산자 중 실수 타입(float, double)이 있을 경우, 허용 범위가 큰 실수 타입으로 변환된 후 연산을 수행함  



(예시) 산술 연산자

```java
int i1 = 10;
int i2 = 4;
int result1 = i1 / i2; // 2
double result2 = i1 / i2; // 2.0
```

result2의 경우 i1 / i2 연산 후의 결과가 2이므로 이것을 실수화해서 2.0이 저장됨  

만약 2.5를 산출 결과로 얻고 싶다면?

```java
double result3 = (double) i1 / i2; // 2.5
double result4 = i1 / (double) i2; // 2.5
double (i1 * 1.0) / i2; // 2.5
```



(예시) char 타입의 산술 연산

```java
char c1 = 'A' + 1;
char c2 = 'A';
//char c3 = c2 + 1; // 컴파일 오류 발생
char c3 = (char) (c2 + 1);
```

char c1 = 'A' + 1; 연산의 경우 리터럴 간의 연산은 컴파일 단계에서 수행하기 때문에 타입 변환이 없어 아무런 문제가 없음  

단, char c3 = c2 + 1;와 같은 변수 연산의 경우 타입 변환이 일어나므로 int 결과 값을 char 타입인 c3에 저장할 수 없어 컴파일 에러가 발생함  



##### 문자열 결합 연산자(+)   

피연산자 중 한쪽이 문자열인 경우 + 연산자는 문자열 결합 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합함  



```java
String str1 = "JDK" + 6.0; // JDK6.0
String str2 = str1 + " 특징";  // JDK6.0 특징
String str3 = "JDK" + 3 + 3.0; // JDK33.0
String str4 = 3 + 3.0 + "JDK" // 6.0JDK
```



##### 비교 연산자(<, <=, >, >=, ==, !=)

비교 연산자는 피연산자의 대소 또는 동등을 비교해서 true/false를 산출함  

비교 연산자는 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 이용되어 실행 흐름을 제어할 때 사용됨  

| 구분      | 연산식                 | 설명                             |
| --------- | ---------------------- | -------------------------------- |
| 동등 비교 | 피연산자1 == 피연산자2 | 두 피연산자의 값이 같은지를 검사 |
|           | 피연산자1 != 피연산자2 | 두 피연산자의 값이 다른지를 검사 |
| 크기 비교 | 피연산자1 > 피연산자2  | 피연산자1이 큰지를 검사          |
|           | 피연산자1 >= 피연산자2 | 피연산자1이 크거나 같은지를 검사 |
|           | 피연산자1 < 피연산자2  | 피연산자1이 작은지를 검사        |
|           | 피연산자1 <= 피연산자2 | 피연산자1이 작거나 같은지를 검사 |

*만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행함*

*비교 연산의 경우에도 연산을 수행하기 전에 피연산자의 타입을 일치시킴*

*(예외) 0.1 == 0.1f : false 출력*

실수의 저장 방식인 부동 소수점 방식이 0.1을 정확히 표현할 수 없기 때문에 0.1f는 0.1의 근사값(0.10000000149011612)으로 표현되어 0.1보다 큰 값이 되어 버림  



##### (추가) String 변수 비교

참조 타입인 String 문자열을 비교할 때에는 equals() 메소드를 사용함    

```java
String str1 = "강아지";
String str2 = "강아지";

System.out.println(str1.equals(str2)); // true
System.out.println(!str1.equals(str2)); // false
```



##### 논리 연산자(&&, ||, &, |, ^, !)  

논리곱(&&), 논리함(||), 배타적 논리합(^), 논리 부정(!)을 수행하는 연산자  

피연산자는 boolean 타입만 사용할 수 있음  

| 구분               | 연산식           | 결과  | 설명                                                         |
| ------------------ | ---------------- | ----- | ------------------------------------------------------------ |
| AND(논리곱)        | true && true     | true  | 피연산자가 모두 true일 경우에만 연산 결과가 true             |
|                    | true && false    | false |                                                              |
|                    | false && true    | false |                                                              |
|                    | false && false   | false |                                                              |
| OR(논리합)         | true \|\| true   | true  | 피연산자 중 하나만 true이면 연산 결과는 true                 |
|                    | true \|\| false  | true  |                                                              |
|                    | false \|\| true  | true  |                                                              |
|                    | false \|\| false | false |                                                              |
| XOR(배타적 논리합) | true ^ true      | false | 피연산자 중 하나는 true이고 다른 하나는 false일 경우에만 연산 결과가 true |
|                    | true ^ false     | true  |                                                              |
|                    | false ^ true     | true  |                                                              |
|                    | false ^ false    | false |                                                              |
| NOT(논리 부정)     | !true            | false | 피연산자의 논리값을 바꿈                                     |
|                    | !false           | true  |                                                              |

&& 대신 &를, || 대신 |를 사용해도 산출 결과는 같지만 둘의 연산 과정이 조금 다름  

&&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 산출 결과를 내므로 두 피연산자 모두를 평가해서 산출 결과를 내는 & 보다 더 효율적으로 동작함   

마찬가지로 ||는 앞의 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true라는 산출 결과를 냄  



##### 대입 연산자(=, +=, -=, *=, /=, %=)  

대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장함  

| 구분             | 연산식            | 설명                                    |
| ---------------- | ----------------- | --------------------------------------- |
| 단순 대입 연산자 | 변수 = 피연산자   | 오른쪽 피연산자의 값을 왼쪽 변수에 저장 |
| 복합 대입 연산자 | 변수 += 피연산자  | 변수 = 변수 + 피연산자와 동일           |
|                  | 변수 -= 피연산자  | 변수 = 변수 - 피연산자와 동일           |
|                  | 변수 *= 피연산자  | 변수 = 변수 * 피연산자와 동일           |
|                  | 변수 /= 피연산자  | 변수 = 변수 / 피연산자와 동일           |
|                  | 변수 %= 피연산자  | 변수 = 변수 % 피연산자와 동일           |
|                  | 변수 &= 피연산자  | 변수 = 변수 & 피연산자와 동일           |
|                  | 변수 \|= 피연산자 | 변수 = 변수 \| 피연산자와 동일          |
|                  | 변수 ^= 피연산자  | 변수 = 변수 ^ 피연산자와 동일           |

대입 연산자는 모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있기 때문에 제일 마지막에 수행됨  



### 03-2-3. 삼항 연산자

###### 삼항 연산자(?:)

3개의 피연산자를 필요로 하는 연산자

? 앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고도 부름  

`조건식(피연산자1) ? 값 또는 연산식(피연산자2) : 값 또는 연산식(피연산자3)`

조건식을 연산하여 true가 나오면 삼항 연산자의 결과는 피연산자2가 되며, false가 나오면 결과는 피연산자3이 됨



(예시) 

```java
package sec02.exam11;

public class ConditionalOperationExample {

	public static void main(String[] args) {
		int score = 85;
		char grade = (score > 90) ? 'A' : ((score > 80) ? 'B' : 'C');
		System.out.println(score + "점은 " + grade + "등급입니다.");
	}

} // 출력 결과 : 85점은 B등급입니다.
```





